#imports
import os, sys, glob, ast

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

from blimpy import Waterfall
from turbo_seti.find_event.plot_event import plot_waterfall
from blimpy.io.hdf_reader import H5Reader

import matplotlib as mpl
mpl.rcParams['agg.path.chunksize'] = 10000

def band(file, tol=0.7):
    """
    Determine the frequency band of an observation file.
    
    This function analyzes the frequency coverage of an HDF5 observation file
    and determines which standard radio astronomy band it belongs to (L, S, C, or X).
    This information is used for appropriate frequency range selection in plots.
    
    Parameters
    ----------
    file : str
        Path to HDF5 observation file to analyze.
    tol : float, default=0.7
        Tolerance in GHz for band matching. Frequencies must be within this
        tolerance of standard band edges to be classified.
        
    Returns
    -------
    list or str
        If matched: List of [min_freq, max_freq] in GHz for the identified band.
        If no match: String "NA" indicating no standard band classification.
        
    Standard Bands
    --------------
    - L band: 1.10 - 1.90 GHz
    - S band: 1.80 - 2.80 GHz  
    - C band: 4.00 - 7.80 GHz
    - X band: 7.80 - 11.20 GHz
        
    Notes
    -----
    Reads frequency information from HDF5 header without loading observation data.
    Uses 'fch1' (first channel frequency) and 'foff' (channel offset) to calculate
    the frequency range covered by the observation.
    
    Examples
    --------
    Determine band for an observation:
    
    >>> band_info = band("observation_lband.h5")
    >>> print(f"Band: {band_info}")  # [1.10, 1.90]
    
    >>> band_info = band("observation_xband.h5") 
    >>> if band_info != "NA":
    ...     print(f"X-band observation: {band_info[0]}-{band_info[1]} GHz")
    """

    L = [1.10, 1.90]
    S = [1.80, 2.80]
    C = [4.00, 7.80]
    X = [7.80, 11.20]

    h5 = H5Reader(file, load_data=False)
    hdr = h5.read_header()

    dirMaxf = hdr['fch1'] * 10**-3
    dirMinf = dirMaxf - np.abs(hdr['foff']*hdr['nchans'])*10**-3

    if abs(dirMinf-L[0]) < tol and abs(dirMaxf-L[1]) < tol:
        return L
    elif abs(dirMinf-S[0]) < tol and abs(dirMaxf-S[1]) < tol:
        return S
    elif abs(dirMinf-C[0]) < tol and abs(dirMaxf-C[1]) < tol:
        return C
    elif abs(dirMinf-X[0]) < tol and abs(dirMaxf-X[1]) < tol:
        return X
    else:
        return 'NA'

def decryptSepName(path):
    """
    Extract satellite name and target name from separation CSV file path.
    
    This utility function parses the standardized filename format used for
    satellite separation CSV files to extract the satellite name and observation
    target name for labeling plots and organizing results.
    
    Parameters
    ----------
    path : str
        Full path to a satellite separation CSV file.
        Expected format: "{satellite_name}_separation_{target}_{timestamp}.csv"
        
    Returns
    -------
    tuple of (str, str)
        - Satellite name with underscores converted to spaces and hyphens cleaned
        - Target name extracted from the filename
        
    Notes
    -----
    The function expects filenames generated by the findSats function, which follow
    a specific naming convention. It handles formatting inconsistencies like
    replacing underscores with spaces and cleaning up hyphen formatting.
    
    Examples
    --------
    Extract names from separation file:
    
    >>> sat_name, target = decryptSepName("/data/GPS_BIIR-2_separation_target123_data.csv")
    >>> print(f"Satellite: {sat_name}, Target: {target}")
    # Output: "Satellite: GPS BIIR 2, Target: target123"
    """

    name = os.path.split(path)[1]

    ii = name.find('separation')

    sat = name[:ii].replace('_', ' ').split('-')
    newSat = sat[0]

    target = name[ii+11:].split('_')[0]

    return newSat, target

def plotH5(satCsv, h5Path, memLim=20, work_dir=None):
    """
    Generate waterfall plot of HDF5 observation data with satellite information.
    
    This function creates a frequency vs. time waterfall plot of radio astronomy
    observation data, providing visual context for potential satellite interference.
    The plot shows the full observation with appropriate frequency band limits.
    
    Parameters
    ----------
    satCsv : list of str
        List of paths to satellite separation CSV files associated with this observation.
        Used to extract satellite names for plot labeling.
    h5Path : str
        Path to HDF5 observation file to plot.
    memLim : int, default=20
        Memory limit in GB for loading observation data. Larger files may require
        higher limits. Increase for X-band observations which can be very large.
    work_dir : str, optional
        Directory to save the plot file. If None, uses current working directory.
        
    Raises
    ------
    Exception
        If the observation file frequency band cannot be determined (returns "NA").
        
    Notes
    -----
    - Automatically determines appropriate frequency range based on observation band
    - Uses blimpy library for HDF5 data handling and plotting
    - Saves plot as PNG with filename: "{target}_{satellites}_wf.png"
    - Plot shows full time duration with band-appropriate frequency limits
    - Large files are handled with memory limits to prevent crashes
    
    Examples
    --------
    Plot observation with satellite information:
    
    >>> sat_files = ["GPS_sat1_separation_target.csv", "GPS_sat2_separation_target.csv"]
    >>> plotH5(sat_files, "observation_lband.h5", memLim=40, work_dir="/plots/")
    
    Plot with default settings:
    
    >>> plotH5(["satellite_separation.csv"], "obs.h5")
    """

    # Set work directory, default to current working directory
    if work_dir is None:
        work_dir = os.getcwd()
    
    # Ensure work_dir exists
    os.makedirs(work_dir, exist_ok=True)

    # get target name and sat names
    sats = []
    for csv in satCsv:
        satName, targetName = decryptSepName(csv)
        sats.append(satName.lstrip('_').rstrip('_'))

    sats = np.unique(np.array(sats))
    satName = ""
    for sat in sats:
        satName += sat + ", "

    satName = satName[:-2]

    # plot waterfall
    wf = Waterfall(h5Path, max_load=memLim)

    b = band(h5Path)
    if type(b) == str:
        raise Exception("No band found for this file")

    plt.figure(figsize=(19.5, 15))
    wf.plot_all(f_start=b[0]*10**3, f_stop=b[1]*10**3)
    plot_path = os.path.join(work_dir, f"{targetName}_{satName.replace(' ','_')}_wf.png")
    plt.savefig(plot_path, bbox_inches='tight', transparent=False)
    plt.close()

def plotSep(satCsv, work_dir=None):
    """
    Generate separation plot from satellite separation CSV data.
    
    This function creates a line plot showing the angular separation between a
    satellite and the observation target over time, with the minimum separation
    point highlighted. This visualization helps assess the severity of potential
    satellite interference.
    
    Parameters
    ----------
    satCsv : str
        Path to CSV file containing satellite separation data.
        File should have columns: 'Time after start', 'Separation'.
    work_dir : str, optional
        Directory to save the plot file. If None, uses current working directory.
        
    Notes
    -----
    - Creates line plot with separation (degrees) on x-axis, time (seconds) on y-axis
    - Highlights minimum separation point with orange scatter marker
    - Includes legend showing satellite name and minimum separation details
    - Saves as PNG with filename: "{target}_{satellite}_separation.png"  
    - Plot dimensions: 8x10 inches for good visibility of details
    
    Examples
    --------
    Generate separation plot:
    
    >>> plotSep("GPS_BIIR-2_separation_target123_data.csv", work_dir="/plots/")
    
    Plot with default output directory:
    
    >>> plotSep("satellite_separation_data.csv")
    """

    # Set work directory, default to current working directory
    if work_dir is None:
        work_dir = os.getcwd()
    
    # Ensure work_dir exists
    os.makedirs(work_dir, exist_ok=True)

    # get target name and sat name
    satName, targetName = decryptSepName(satCsv)

    # plot separation
    df = pd.read_csv(satCsv)
    time = df['Time after start']
    sep = df['Separation']

    fig, ax = plt.subplots(figsize=(8,10))
    ax.plot(sep, time, label=satName)
    ax.set_ylabel('Time [s]')
    ax.set_xlabel('Seperation [degrees]')

    minpoint = min(sep)

    minindex = np.where(sep == minpoint)[0] #df['Separation'].index(minpoint)
    mintime = int(time[minindex])

    ax.scatter(minpoint, mintime, s = 50, label = 'Min: ' + str("%.5fdeg" % minpoint) + ', ' + str(mintime) + "s", color='orange')

    ax.legend();
    plot_path = os.path.join(work_dir, f"{targetName}_{satName.replace(' ', '_')}_separation.png")
    fig.savefig(plot_path, bbox_inches='tight', transparent=False)
    plt.close(fig)

def main():

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--h5Dir', help='Directory with h5 files to run on', default=None)
    parser.add_argument('--memLim', help='Memory limit for reading in the h5 files', default=40)
    parser.add_argument('--work_dir', help='directory to store output files, defaults to current working directory', default=None)
    args = parser.parse_args()

    # Set work directory, default to current working directory
    work_dir = args.work_dir if args.work_dir else os.getcwd()
    os.makedirs(work_dir, exist_ok=True)

    affectedFiles = pd.read_csv(os.path.join(work_dir, 'files_affected_by_sats.csv'))

    csvs = np.array([ast.literal_eval(x) for x in affectedFiles['csvPaths']])

    if not args.h5Dir:
        h5Files = np.array(affectedFiles['filepath'])
        h5Files = h5Files[affectedFiles['satellite?'] == True]
    else:
        if args.h5Dir[-1] != '/':
            args.h5Dir += '/'
        h5Files = glob.glob(args.h5Dir + '*.h5')

    for csvList, h5 in zip(csvs, h5Files):
        print(f'Plotting for {h5}')
        plotH5(csvList, h5, memLim=args.memLim, work_dir=work_dir)
        for csv in csvList:
            plotSep(csv, work_dir=work_dir)


if __name__ == '__main__':
    sys.exit(main())
